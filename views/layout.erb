<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>shabbat.md — Make Agents Kosher Again</title>
  <meta name="description" content="A simple, open format for declaring Shabbat and Yom Tov compliance settings for AI coding agents. Because your tools should rest when you do." />
  <meta property="og:title" content="shabbat.md" />
  <meta property="og:description" content="Make Agents Kosher Again. A simple, open format for Shabbat-compliant AI agent configuration." />
  <meta property="og:url" content="https://shabbatmd.com" />
  <meta property="og:image" content="https://shabbatmd.com/social-thumbnail.png" />
  <meta name="twitter:title" content="shabbat.md" />
  <meta name="twitter:description" content="Make Agents Kosher Again. A simple, open format for Shabbat-compliant AI agent configuration." />
  <meta name="twitter:image" content="https://shabbatmd.com/social-thumbnail.png" />
  <meta name="twitter:card" content="summary_large_image" />

  <!-- Prevent dark mode flash — must run before body renders -->
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark')
    }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Geist+Mono:wght@400;500&display=swap" rel="stylesheet" />

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            sans: ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'Inter', 'sans-serif'],
            mono: ['Geist Mono', 'ui-monospace', 'monospace'],
          },
        }
      }
    }
  </script>

  <style>
    html { scroll-behavior: smooth; }
    #hero-title .char {
      transition: color 90ms linear, text-shadow 90ms linear;
    }

    #hero-title .char.shimmer {
      color: #2563eb;
      text-shadow: 0 0 10px rgba(37, 99, 235, 0.35);
    }

    #hero-title .char.pre-shimmer {
      color: #1e3a8a;
      text-shadow: 0 0 8px rgba(30, 58, 138, 0.3);
    }

    html.dark #hero-title .char.shimmer {
      color: #93c5fd;
      text-shadow: 0 0 10px rgba(147, 197, 253, 0.45);
    }

    html.dark #hero-title .char.pre-shimmer {
      color: #c6dffc;
      text-shadow: 0 0 8px rgba(198, 223, 252, 0.32);
    }

    /* Details/summary reset (kept for any native usage) */
    details > summary { list-style: none; }
    details > summary::-webkit-details-marker { display: none; }
    details > summary::marker { display: none; }

    /* Focus rings */
    :focus:not(:focus-visible) { outline: none; box-shadow: none; }
    :focus-visible { outline: 2px solid #3b82f6; outline-offset: 2px; border-radius: 2px; }

    body {
      font-size: 16px;
      line-height: 1.85;
    }

    /* Light mode code block — GitHub light palette */
    .code-block {
      background: #f6f8fa;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow-x: auto;
    }

    .code-block pre {
      padding: 1.25rem 1.5rem;
      font-family: 'Geist Mono', ui-monospace, monospace;
      font-size: 0.8125rem;
      line-height: 1.85;
      color: #24292f;
    }

    .comment  { color: #6e7781; }
    .key      { color: #0550ae; }
    .val-str  { color: #116329; }
    .val-bool { color: #cf222e; }
    .section  { color: #953800; }

    /* Dark mode code block — dark blue, lighter than body */
    html.dark .code-block {
      background: #0f1624;
      border-color: #1a2642;
    }

    html.dark .code-block pre { color: #e6edf3; }
    html.dark .comment  { color: #8b949e; }
    html.dark .key      { color: #79c0ff; }
    html.dark .val-str  { color: #7ee787; }
    html.dark .val-bool { color: #ff7b72; }
    html.dark .section  { color: #e3b341; }

    .verdict-dot {
      display: inline-block;
      width: 7px;
      height: 7px;
      border-radius: 50%;
      margin-right: 6px;
      flex-shrink: 0;
      position: relative;
      top: -1px;
    }

    /* Hebrew term tooltips — light mode */
    .heb {
      text-decoration-line: underline;
      text-decoration-style: dotted;
      text-decoration-color: #9ca3af;
      text-underline-offset: 3px;
      cursor: help;
      position: relative;
    }

    .heb::after {
      content: attr(data-def);
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: #111827;
      color: #f9fafb;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Inter', sans-serif;
      font-size: 0.72rem;
      font-style: normal;
      line-height: 1.5;
      padding: 5px 10px;
      border-radius: 5px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 100;
      max-width: 380px;
      min-width: 220px;
      white-space: normal;
      text-align: left;
    }

    .heb::before {
      content: '';
      position: absolute;
      bottom: calc(100% + 3px);
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: #111827;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease;
      z-index: 100;
    }

    .heb:hover::after,
    .heb:hover::before { opacity: 1; }

    /* Dark mode: invert tooltip to light */
    html.dark .heb::after {
      background: #f1f5f9;
      color: #0f172a;
    }
    html.dark .heb::before {
      border-top-color: #f1f5f9;
    }

    /* FAQ panel starts closed */
    .faq-panel {
      height: 0;
      overflow: hidden;
    }

    /*
     * Progressive blur — stacked layers, each covering a smaller zone with
     * increasing blur and a mask that fades it out, mimicking the GLSL
     * smoothstep gradient used in the WebGL shader approach.
     */
    .pb-wrap {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 50;
    }
    .pb {
      position: absolute;
      left: 0;
      right: 0;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
    }
    /* Top layers: large zone/soft → small zone/strong */
    .pb.top { top: 0; }
    .pb.top.l1 { height: 140px; -webkit-mask-image: linear-gradient(to bottom, black 0%, transparent 100%); mask-image: linear-gradient(to bottom, black 0%, transparent 100%); }
    .pb.top.l2 { height: 90px;  -webkit-mask-image: linear-gradient(to bottom, black 0%, transparent 100%); mask-image: linear-gradient(to bottom, black 0%, transparent 100%); }
    .pb.top.l3 { height: 55px;  -webkit-mask-image: linear-gradient(to bottom, black 0%, transparent 100%); mask-image: linear-gradient(to bottom, black 0%, transparent 100%); }
    .pb.top.l4 { height: 28px;  -webkit-mask-image: linear-gradient(to bottom, black 0%, transparent 100%); mask-image: linear-gradient(to bottom, black 0%, transparent 100%); }
    /* Bottom layers */
    .pb.bottom { bottom: 0; }
    .pb.bottom.l1 { height: 140px; -webkit-mask-image: linear-gradient(to top, black 0%, transparent 100%); mask-image: linear-gradient(to top, black 0%, transparent 100%); }
    .pb.bottom.l2 { height: 90px;  -webkit-mask-image: linear-gradient(to top, black 0%, transparent 100%); mask-image: linear-gradient(to top, black 0%, transparent 100%); }
    .pb.bottom.l3 { height: 55px;  -webkit-mask-image: linear-gradient(to top, black 0%, transparent 100%); mask-image: linear-gradient(to top, black 0%, transparent 100%); }
    .pb.bottom.l4 { height: 28px;  -webkit-mask-image: linear-gradient(to top, black 0%, transparent 100%); mask-image: linear-gradient(to top, black 0%, transparent 100%); }
  </style>
</head>
<body class="bg-white dark:bg-[#0a0f1a] text-gray-800 dark:text-gray-200 font-sans antialiased">
  <div class="pb-wrap" aria-hidden="true">
    <div class="pb top l1"></div>
    <div class="pb top l2"></div>
    <div class="pb top l3"></div>
    <div class="pb top l4"></div>
    <div class="pb bottom l1"></div>
    <div class="pb bottom l2"></div>
    <div class="pb bottom l3"></div>
    <div class="pb bottom l4"></div>
  </div>
  <%= yield %>

  <script type="module">
    import { animate, inView } from "https://cdn.jsdelivr.net/npm/motion@11/+esm"

    // ── Hero title reveal (Hebrew -> scramble -> final) ───────────────
    const heroTitleEl = document.getElementById('hero-title')
    if (heroTitleEl) {
      const finalTitle = 'shabbat.md'
      const initialHebrew = 'שבת.מד'
      const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*+-?'

      const renderTitle = (text, shimmerIndex = -1, preShimmerIndex = -1) => {
        heroTitleEl.innerHTML = text
          .split('')
          .map((ch, idx) => {
            const className = idx === shimmerIndex
              ? 'char shimmer'
              : idx === preShimmerIndex
                ? 'char pre-shimmer'
                : 'char'
            return `<span class="${className}">${ch}</span>`
          })
          .join('')
      }

      renderTitle(initialHebrew)

      const randomChar = () => randomChars[Math.floor(Math.random() * randomChars.length)]

      window.setTimeout(() => {
        const seedText = initialHebrew
          .repeat(Math.ceil(finalTitle.length / initialHebrew.length))
          .slice(0, finalTitle.length)
        const staggerFrames = 2
        const scrambleFramesPerChar = 4
        const totalFrames = staggerFrames * (finalTitle.length - 1) + scrambleFramesPerChar
        let frame = 0

        const timer = window.setInterval(() => {
          const shimmerIndex = Math.min(finalTitle.length - 1, Math.floor(frame / staggerFrames))
          const preShimmerIndex = Math.max(-1, shimmerIndex - 1)

          const frameText = finalTitle
            .split('')
            .map((char, idx) => {
              const start = idx * staggerFrames
              const end = start + scrambleFramesPerChar
              if (frame < start) return seedText[idx]
              if (frame < end) return randomChar()
              return char
            })
            .join('')
          renderTitle(frameText, shimmerIndex, preShimmerIndex)

          frame += 1
          if (frame > totalFrames) {
            window.clearInterval(timer)
            heroTitleEl.textContent = finalTitle
          }
        }, 28)
      }, 500)
    }

    // ── Dark mode toggle ──────────────────────────────────────────────
    document.getElementById('theme-toggle')?.addEventListener('click', () => {
      const isDark = document.documentElement.classList.toggle('dark')
      localStorage.theme = isDark ? 'dark' : 'light'
    })

    // ── Hero entrance animation ────────────────────────────────────────
    animate(
      '#hero-content',
      { opacity: [0, 1], transform: ['translateY(20px)', 'translateY(0px)'] },
      { duration: 0.6, easing: [0.25, 0.46, 0.45, 0.94], delay: 0.05 }
    )

    // ── Scroll-in animations for sections ─────────────────────────────
    document.querySelectorAll('[data-animate]').forEach(el => {
      el.style.opacity = '0'
      el.style.transform = 'translateY(18px)'
    })

    inView('[data-animate]', (entry) => {
      animate(
        entry.target,
        { opacity: [0, 1], transform: ['translateY(18px)', 'translateY(0px)'] },
        { duration: 0.5, easing: [0.25, 0.46, 0.45, 0.94] }
      )
    }, { amount: 0.08 })

    // ── FAQ accordion ─────────────────────────────────────────────────
    document.querySelectorAll('.faq-trigger').forEach(trigger => {
      const panel   = trigger.nextElementSibling
      const chevron = trigger.querySelector('.faq-chevron')

      trigger.addEventListener('click', () => {
        const isOpen  = trigger.getAttribute('aria-expanded') === 'true'
        const opening = !isOpen
        trigger.setAttribute('aria-expanded', String(opening))

        const opts = { duration: 0.25, easing: [0.16, 1, 0.3, 1] }
        if (opening) {
          panel.style.height = '0px'
          const targetH = panel.scrollHeight
          animate(panel, { height: [`0px`, `${targetH}px`] }, opts)
            .finished.then(() => { panel.style.height = 'auto' })
          animate(chevron, { rotate: 180 }, opts)
        } else {
          panel.style.height = panel.getBoundingClientRect().height + 'px'
          animate(panel,   { height: '0px' }, opts)
          animate(chevron, { rotate: 0 },     opts)
        }
      })
    })

    // ── Progressive blur + chromatic aberration, scroll-velocity reactive ─
    ;(() => {
      const BASE    = [2, 6, 14, 28]
      const tops    = [...document.querySelectorAll('.pb.top')]
      const bottoms = [...document.querySelectorAll('.pb.bottom')]
      let lastY = window.scrollY, vel = 0, scale = 0

      function setBlur(els, blurs) {
        els.forEach((el, i) => {
          const v = `blur(${blurs[i].toFixed(1)}px)`
          el.style.backdropFilter = v
          el.style.webkitBackdropFilter = v
        })
      }

      function tick() {
        const y   = window.scrollY
        const raw = Math.abs(y - lastY)
        lastY     = y
        vel       = vel * 0.6 + raw * 0.4
        const target = Math.min(vel / 12, 3)
        scale     = scale * 0.72 + target * 0.28
        setBlur(tops, BASE.map(b => b * scale))
        setBlur(bottoms, BASE.map(b => b * scale))
        requestAnimationFrame(tick)
      }
      tick()
    })()

    // ── Smooth anchor scroll ───────────────────────────────────────────
    document.querySelectorAll('a[href^="#"]').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault()
        document.querySelector(a.getAttribute('href'))?.scrollIntoView({ behavior: 'smooth' })
      })
    })
  </script>
</body>
</html>
